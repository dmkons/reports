Presents the results: what has been successfully completed and what did not work.
If any ways around it were found, provide them at this place.
Every solution should be tested for its validity.
This is the place where you will describe what kind of testing you have performed and what the outcome of your tests was.

\subsection{Tests}

Testing is an important part of any kind of development, be it software development or other kinds of development.
This subsection presents the different kinds of tests performed.

\subsubsection{VHDL Test Benches}

In VHDL, one has the possibility to create test benches to validate VHDL components.
A test bench is a piece of VHDL code that instantiates a component, manipulates its in-signals, and measures the output the component sends out again.
It is the hardware design analog of unit testing in regular software development.
These test benches are typically run in simulator software such as ISim or ModelSim, which simulates hardware in an easily measurable and inspectable environment.

VHDL supports a basic \texttt{assert} statement that can be used to programatically compare simulated values against expected results, and with the optional \texttt{report} keyword, additionally print a string to the console fi the assertion fails.
VHDL's support for automatic non-data-driven unit testing beyond the basic \texttt{assert} statement is rather lacking.
Specifically, it shows neither the expected value of the assertion, nor the actual value found.
Because of this, a VHDL package called \texttt{test\_utils} was written.
It contains a convenient testing function, creatively called \texttt{test}.
It supports printing expected values and actual found values, as well as a simple tagging and naming system.
The latter makes it easier to give meaningful names to the different asserts in a test bench.

Generally, each component made in VHDL should have a corresponding test bench.
Because a component is typically defined in its own file, a common test bench scheme is to have one file, "\texttt{my\_entity.vhd}", which defined the component, and one file, "\texttt{tb\_my\_entity.vhd}", which defines the test bench for the component.
Of course, here \texttt{my\_component} is a placeholder name for a component.

In this assignment, each component has an corresponding automatic test bench, which aims to verify correct functionality for a component.
The tests were run in the hardware simulation tool called ISim (TODO: reference ISim version etc).
See appendix (TODO: appendix numbers) for detailed results of each test bench simulation.

\subsubsection{Testing on the Spartan-6 FPGA}

It is also possible to run toplevel test benches directly on the FPGA (I think).
TODO: write more about this.

\subsubsection{Energy Efficiency}

Any computer-related report worth its salt should ontain a section that discusses the energy efficiency of the presented solution.
This report is no different.
The solution processor was not designed with energy efficiency as a primary design goal.
It does, however strive for simplicity in its VHDL design, using official IEEE-reccomended industry standards for as many operations as possible.
This lets the synthesizer use its intimate knowledge of the feature set of the target FPGA to create customized hardware configurations that exploit the possibilities the FPGA provides.
This means that dedicated utility slices, block ram sections and similar will be used where possible.
They are typically faster than their custom logic counterparts, and therefore allow for quicker execution.
Although quicker execution by virtue of increased clock speeds does not change the energy efficiency of the processor for finite terminating programs, it may allow other dependant components in a larger system to enter low energy states quicker, and thereby reducing static energy loss in the system as a whole.

To make the processor more energy efficient, sleep states could be introduced.
They allow the processor to enter low energy states when it is not needed, i.e. typically when it is waiting for an external signal in a larger system, and when it has nothing else useful to do.

TODO: insert energy efficiency measurements.

\subsubsection{Performance}

The presented solution processor performs rather well for a sequential simple multi cycle processor.
The clock's maximum speed is (TODO: insert max clock speed).
In testing, it performs reliably in with clock speeds up to X at temperature Y.
Being a multi-cycle processor, most instructions take more than one cycle to complete.
Instructions that only operate on immediates and registers take two cycles to complete.
Instructions that access the data memory require an additional cycle, for a total of three cycles.
This means that under optimal conditions, the processor is capable of X/2 instructions per second (ref IPS).

To further increase performance, we could introduce instruction-level parallelism in the form of a pipeline.
This, however, is out of the scope of this exercise.
