Describes your solution of the task.
Contains a detailed description of all the subtasks which have been solved and how they contribute to the solution for the given task.
The use of diagrams, figures, tables and similar is welcome as a support to your description.

The processor presented as a solution for assignment 1 in this report is a 32-bit simple MIPS-inspired multi-cycle processor described in VHDL and programmed onto a Xilinx Spartan-6 LX25 FPGA.

\section{Solution Architecture}

\input{solution/solution-architecture.tex}


\subsection{ALU}

Something about the alu. We could mention that we rewrote it because of reasons?

\subsection{Control Unit}

The control unit is a finite state machine that controls the processor.
Its job is to maintain the control state across cycles, and distribute the correct control signals to the other components in the processor at the right time.
The finite state machine has three states: fetch, execute and stall.
It advances to the next state on every cycle, with transitions as illustrated in figure \ref{figure:control-unit-state-machine}.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm, semithick]
            \tikzstyle{every state}=[fill=none,draw=black,text=black]
            \node[initial,state] (fetch)                    {$fetch$};
            \node[state]         (execute) [right of=fetch] {$execute$};
            \node[state]         (stall) [right of=execute] {$stall$};
            \path (fetch) edge node {} (execute)
                (execute) edge [bend left] node {non-mem} (fetch)
                (execute) edge node {mem} (stall)
                (stall) edge [bend right] node {} (fetch);
        \end{tikzpicture}
            \caption{
                Control unit state machine.
                \texttt{mem} transitions are taken when the currently executed instruction accesses memory.
            }
            \label{figure:control-unit-state-machine}
    \end{center}
\end{figure}

TODO: explain the signals that come out of the control unit

Here is a list for now populated by the signal names and Odd's educated guesses and brief explanations of the obvious.

\subsubsection{ALU Source}
The control signal for the ALU Source MUX. If 1 then the MUX selects the output from Sign Extend, if 0 it selects the signal from Read Data 2 in the Registers block.

\subsubsection{Register Write}
Does this turn on if we are writing to a register?

\subsubsection{Register Destination}
If 1 then the the Register Destination MUX outputs bits 15-11 of the instruction. If 0 then it outputs bits 20-16 of the instruction. Either way it feeds this to the Write Register port on the Registers block.

\subsubsection{Memory to Register}
Is this like, fetch? Are we putting memory in the registers?

\subsubsection{Memory Write}
I guess this is set if the instruction writes to memory?

\subsubsection{Jump}
The Jump signal indicates whether or not the current instruction is a jump instruction. If it is, the Jump signal is set to $1$ which causes the Jump MUX to output the Jump Address signal from Concat.

\subsection{Branch Controller}

The branch controller is the logic unit that decide whether or not the program should branch.
It is seperated from the main controller unit, as it works independently from the state machine (see Figure \ref{figure:control-unit-state-machine} and does not need to follow the clock.
The branch controller reads the opcode field from the instruction, and if it is a branch instruction it will run the logic that is requiered for that instruction.

To handle the simplest operations that compare two registers to each other, the branch controller can simply look at the flags from the ALU to decide if the branch mux should be enabled.
Instructions that compare a register to zero require a bit more work from the branch controller.
The branch controller can send out a zero value that overrides the ALUs source for the y operand, and is compared to the x operand from the register specified in the instruction.

To allow for other compare operations than $x \geq 0$ and $x < 0$, the zero vaule will not always be zero. 
Because the solution processor can only handle integers, $x \geq 1$ can be said to be equivalent with $x > 0$.
This trick means that there is no need to support more than zero and negative (TODO: ZERO AND NEGATIVE WHAT?), and can save quite a bit of complexity in our design without losing performance.
Therefore the zero value from the branch controller varies from -1 to 1. (TODO: WHAT?)

The control unit will assist the branch controller by instructing the ALU to do a subtraction on its inputs, $x - y$, and discard the result.
This will set the zero flag of the ALU if the $x = y$, and the negative flag of the ALU if the $x < y$.
These flags are used by the branch controller to determine whether it should branch or not.

\subsection{Program Counter Cycle}

The program counter cycle is the loop the program counter forms together with the branch and jump circuitry.
The program counter is a D-latch register (TODO: is it?) that holds the address of the next instruction to be fetched.
When no branching or jumping is involved (the "sunny day scenario"), the program counter cycle increments the program counter by one every cycle the control unit tells it to.
This means that the control unit has the opportunity to advance the running program.
The control unit advances the program counter when it is in the execute state, so that a new program counter value is ready for when the control unit enters the fetch state.

When the control unit gives the signal, the program counter may perform a branch or a jump by manipulating the program counter cycle to change the value sent back to the program counter.

TODO: diagram of the program counter cycle.

\subsection{Multiplexer}

The multiplexer... do we even need to talk about it?

\section{Instruction Set}

The solution processor implements a modified subset of the MIPS instruction set.
A quick reference of the MIPS instruction set can be found in Figure 3.4 of the compendium \cite{compendium}.
The instructions, as in regular MIPS, can be on one of three general formats, R, I and J.

The solution processor implements the instructions in table \ref{table:implemented-instructions}.
The processor supports quite a few more instructions than the minimum requirements.
This is done because (TODO: convincing argument).

\begin{table}
    \begin{center}
        \begin{tabular}{r|l}
            \texttt{ADD} & Add \\
            \texttt{ADDI} & Add immediate \\
            \texttt{ADDIU} & Add immediate unsigned \\
            \texttt{ADDU} & Add unsigned \\
            \texttt{AND} & And \\
            \texttt{ANDI} & And immediate \\
            \texttt{BEQ} & Branch if equal \\
            \texttt{BNE} & Branch not equal \\
            \texttt{J} & Jump \\
            \texttt{LUI} & Load upper immediate \\
            \texttt{LW} & Load word \\
            \texttt{MULT} & Multiply \\
            \texttt{MULTU} & Multiply unsigned \\
            \texttt{NOR} & Nor \\
            \texttt{OR} & Or \\
            \texttt{ORI} & Or immediate \\
            \texttt{PASSTHROUGH} & Passthrough (i.e. send the first input through unmodified) \\
            \texttt{SLL} & Shift left logical \\
            \texttt{SLLV} & Shift left logical variable \\
            \texttt{SLT} & Set less than \\
            \texttt{SLTI} & Set less than immediate \\
            \texttt{SLTIU} & Set less than immediate unsigned \\
            \texttt{SLTU} & Set less than unsigned \\
            \texttt{SRA} & Shift right arithmetic \\
            \texttt{SRAV} & Shift right arithmetic variable \\
            \texttt{SRL} & Shift right logical \\
            \texttt{SRLV} & Shift right logical variable \\
            \texttt{SUB} & Subtract \\
            \texttt{SUBU} & Subtract unsigned \\
            \texttt{SW} & Store word \\
            \texttt{XOR} & Xor \\
            \texttt{XORI} & Xor immediate \\
        \end{tabular}
        \smallskip
        \hrule
        \smallskip
        \caption{Implemented instructions}
        \label{table:implemented-instructions}
    \end{center}
\end{table}

\section{Test utilities}

TODO: move the solution component description of the test utilities from results-and-tests here

\section{Deliverables}

This is where we list all the deliverables we're sending in.
