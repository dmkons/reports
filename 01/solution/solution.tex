The processor presented as a solution for assignment 1 in this report is a simple 32-bit MIPS-inspired multi-cycle processor described in VHDL.
It was attempted programmed onto a Xilinx Spartan-6 LX25 FPGA.

\section{Solution Architecture}

\input{solution/solution-architecture.tex}

\subsection{ALU}

The ALU in the solution processor has been completely rewritten from scratch.
This was done so that the IEEE industry standard packages \texttt{numeric\_std} could be used.
Using \texttt{numeric\_std}, developers can safely express complex processes in a succinct and easy-to-read fashion, using the many built-in features.
Using industry standards for the solution processor was a goal for two reasons.
First, choosing the conventions and standards recommended by the industry is typically a good idea, as industry leaders have a lot of experience in their field.
Second, using well-documented and feature-rich standard libraries facilitate the implementation of many different CPU instructions, which was a prioritized goal for this exercise.

Although the suggested architecture in the compendium features an ALU control unit\cite{compendium}, it does not exist in the solution architecture.
Instead, the ALU control unit's responsibilities are covered for by the regular control unit.
This design choice was made for the flexibility it provides in implementing more instructions.

\subsection{Branch Controller}

The branch controller the logic unit that decides whether or not the program should branch.
It is separate from the main control unit, as it works independently from the control unit state machine, and does not need to follow the clock.
The branch controller reads the opcode field from the current instruction, looking for branch instructions.
If it finds a branch instruction, it will apply the logic that is required for that instruction.

Having branch logic contained in a separate branch controller gives the opportunity to implement many different branch instructions in a modular manner.

To handle the simplest operations that compare two registers to each other, the branch controller can simply look at the flags from the ALU to decide if the branch MUX should be enabled.
Instructions that compare a register to zero require a bit more work from the branch controller.
The branch controller can send out a zero value that overrides the ALU's source for the $ y $ operand, and is compared to the $ x $ operand from the register specified in the instruction.

To allow for other compare operations than $x \geq 0$ and $x < 0$, the zero value will not always be zero. 
Because the solution processor only handles integers, the comparison $ x \geq 1 $ is equivalent with $ x > 0 $.
This trick means that support for branch operations other than zero and negative are not needed, which nicely reduces complexity in the design without sacrificing performance.
Therefore the zero value from the branch controller vary from -1 to 1.

The control unit drives the branch controller by instructing the ALU to do a subtraction on its inputs, $ x - y $, and ignore the result.
This sets the zero flag of the ALU if the x = y, and the negative flag of the ALU if the x < y.
It is these flags that is used by the branch controller to detemin if it should branch.

\subsection{Control Unit}

The control unit is a finite state machine that controls the processor.
Its job is to maintain the control state across cycles, and distribute the correct control signals to the other components in the processor at the right time.
The finite state machine has three states: fetch, execute and stall.
It advances to the next state on every cycle, with transitions as illustrated in figure \ref{figure:control-unit-state-machine}.
In the figure, \texttt{mem} transitions are taken when the currently executed instruction accesses memory.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm, semithick]
            \tikzstyle{every state}=[fill=none,draw=black,text=black]
            \node[initial,state] (fetch)                    {$fetch$};
            \node[state]         (execute) [right of=fetch] {$execute$};
            \node[state]         (stall) [right of=execute] {$stall$};
            \path (fetch) edge node {} (execute)
                (execute) edge [bend left] node {non-mem} (fetch)
                (execute) edge node {mem} (stall)
                (stall) edge [bend right] node {} (fetch);
        \end{tikzpicture}
            \caption{Control unit state machine.}
            \label{figure:control-unit-state-machine}
    \end{center}
\end{figure}

Because the control unit is so central to understanding how the solution processor works, its in signals and out signals are described here in detail.

\subsubsection{In Signals}

\begin{description}
\item{\textbf{Clock}} \\
The clock signal drives the control unit, letting it know when to progress to the next state, and change its out signals.
The control unit is one of the only components that are directly driven by a clock, as most of the other components are driven by the control unit, and therefore already inderectly clock driven.

\item{\textbf{Instruction Opcode}} \\
The instruction opcode signal contains the opcode of the currently executing instruction.
The control unit uses this signal as the input to its state machine, together with the current state.

\item{\textbf{Instruction Function}} \\
The instruction function signal contains the alu function of the currently execcuting instruction, if available.
It is used to help specify out signals in certain special cases.

\item{\textbf{Processor Enable}} \\
Since the control unit is the driver of the processor, the control unit is the one that must react to the processor enable signal.

\item{\textbf{Reset}} \\
Again, since the control unit is the driver of the processor, the control unit is the one that must react to the reset signal.
\end{description}

\subsubsection{Out Signals}

\begin{description}
    \item{\textbf{Register Destination}} \\
This signal selects which part of an instruction word contains the destination register of an operation.
If 1 then the the Register Destination MUX outputs bits 15-11 of the instruction. If 0 then it outputs bits 20-16 of the instruction.
Either way it feeds this to the Write Register port on the Registers block.

\item{\textbf{Memory To Register}} \\
This signal decides whether or not a word fetched from memory will be stored in a register.

\item{\textbf{Alu Function}} \\
This signal forwards the alu function part of the currently executing instruction to whomever else who may need it.
Notably, recipients include the ALU itself.
In the suggested architecture, this signal is sent from the ALU control unit.
However, since the ALU control unit and the regular control unit have been merged in the solution archtecture, this signal is sent from the regular control unit.

\item{\textbf{Memory Write}} \\
This signal decides whether or not the current value 'at the door of the data memory' so to speak will be accepted and written to the data memory.

\item{\textbf{Alu Source}} \\
This signal controls whether the input to the ALU comes from a register specified by the instruction word, or from the instruction word itself as an immediate.
it is the control signal for the ALU Source MUX.
If 1 then the MUX selects the output from Sign Extend, if 0 it selects the signal from Read Data 2 in the Registers block.

\item{\textbf{Register Write}} \\
This signal controls whether the current output from the ALU (or sometimes from data memory) will be written to a register).

\item{\textbf{PC Enable}} \\
This signal decides when it is time for the Program Counter to advance to it's next value.
This signal is needed because the solution processor is a multi-cycle processor which uses different amount of cycles for different instructions.

\item{\textbf{Jump}} \\
The Jump signal indicates whether or not the current instruction is a jump instruction.
If it is, the Jump signal is set to $ 1 $ which causes the jump address to propagate through to the Program Counter.

\item{\textbf{Shift Swap}} \\
In the MIPS instruction set, there are different instructions to perform shift operations that need different inputs to the ALU in different cases.
The shift swap swaps some of the ALU input signals in certain cases to be able route the correct input signals at the right time.
\end{description}

\subsection{Program Counter Circuit}

The program counter circuit is the loop the program counter forms together with the branch and jump circuitry.
The program counter is a register that holds the address of the next instruction to be fetched.
When no branching or jumping is involved (the ``sunny day scenario''), the program counter cycle increments the program counter by one every time the control unit tells it to.
This means that the control unit has the opportunity to advance the running program.
The control unit advances the program counter when it is in the execute state, so that a new program counter value is ready for when the control unit enters the fetch state.

When the control unit gives the signal, the program counter may perform a branch or a jump by manipulating the program counter circuit to change the value sent back to the program counter.

TODO: diagram of the program counter cycle.

\subsection{Multiplexer}

The multiplexer... do we even need to talk about it?

\section{Instruction Set}

The solution processor implements a modified subset of the MIPS instruction set.
A quick reference of the MIPS instruction set can be found in Figure 3.4 of the compendium \cite{compendium}.
The instructions, as in regular MIPS, can be on one of three general formats, R, I and J.

The solution processor implements the instructions in table \ref{table:implemented-instructions}.
The processor supports quite a few more instructions than the minimum requirements.
This is done in alignment with the design goals set for solution processor.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{r|l}
            \texttt{ADD} & Add \\
            \texttt{ADDI} & Add immediate \\
            \texttt{ADDIU} & Add immediate unsigned \\
            \texttt{ADDU} & Add unsigned \\
            \texttt{AND} & And \\
            \texttt{ANDI} & And immediate \\
            \texttt{BEQ} & Branch if equal \\
            \texttt{BNE} & Branch not equal \\
            \texttt{J} & Jump \\
            \texttt{LUI} & Load upper immediate \\
            \texttt{LW} & Load word \\
            \texttt{MULT} & Multiply \\
            \texttt{MULTU} & Multiply unsigned \\
            \texttt{NOR} & Nor \\
            \texttt{OR} & Or \\
            \texttt{ORI} & Or immediate \\
            \texttt{PASSTHROUGH} & Passthrough (i.e. send the first input through unmodified) \\
            \texttt{SLL} & Shift left logical \\
            \texttt{SLLV} & Shift left logical variable \\
            \texttt{SLT} & Set less than \\
            \texttt{SLTI} & Set less than immediate \\
            \texttt{SLTIU} & Set less than immediate unsigned \\
            \texttt{SLTU} & Set less than unsigned \\
            \texttt{SRA} & Shift right arithmetic \\
            \texttt{SRAV} & Shift right arithmetic variable \\
            \texttt{SRL} & Shift right logical \\
            \texttt{SRLV} & Shift right logical variable \\
            \texttt{SUB} & Subtract \\
            \texttt{SUBU} & Subtract unsigned \\
            \texttt{SW} & Store word \\
            \texttt{XOR} & Xor \\
            \texttt{XORI} & Xor immediate \\
        \end{tabular}
        \smallskip
        \hrule
        \smallskip
        \caption{Implemented instructions}
        \label{table:implemented-instructions}
    \end{center}
\end{table}

\section{Test utilities}

VHDL supports a basic \texttt{assert} statement that can be used to programatically compare simulated values against expected results, and with the optional \texttt{report} keyword, additionally print a string to the console if the assertion fails.
VHDL's support for automatic non-data-driven unit testing beyond the basic \texttt{assert} statement is rather lacking.
Specifically, it shows neither the expected value of the assertion, nor the actual value found.
Because of this, a VHDL package called \texttt{test\_utils} was written.
It contains a convenient testing function, creatively called \texttt{test}.
It supports printing expected values and actual found values, as well as a simple tagging and naming system.
The latter makes it easier to give meaningful names to the different asserts in a test bench.

\section{Deliverables}

This is where we list all the deliverables we're sending in.
